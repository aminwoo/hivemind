#!/usr/bin/env python3
"""
Analyze training data from selfplay parquet files.

This script reads training data generated by the C++ selfplay engine and displays:
- Board positions (from team perspective: uppercase=our pieces, lowercase=opponent)
- Move policy distributions for both boards
- Game outcomes

The data format uses 64 input channels representing two Bughouse boards from the
perspective of one team. Each board has 32 channels encoding pieces, pockets,
castling rights, and other game state information.

Usage:
    # Analyze first few samples from one file
    python analyze_training_data.py --num-samples 3

    # Analyze specific samples
    python analyze_training_data.py --sample-indices "0,100,500"

    # Show raw plane values
    python analyze_training_data.py --num-samples 2 --show-planes
"""

import argparse
import os
import glob
import sys
import numpy as np
import polars as pl
import chess
from chess.variant import CrazyhouseBoard

# Add src to path to import move mapping
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))
from domain.move2planes import make_map

# Constants matching training data format
NB_INPUT_CHANNELS = 64
BOARD_SIZE = 8
NB_POLICY_VALUES = 73 * BOARD_SIZE * BOARD_SIZE  # 4672

# Global move map for decoding move indices
MOVE_MAP = None


def get_move_map():
    """Lazy load the move map."""
    global MOVE_MAP
    if MOVE_MAP is None:
        MOVE_MAP = make_map()
    return MOVE_MAP


def decode_move_index(move_idx: int) -> str:
    """Convert a move index to a human-readable move string."""
    move_map = get_move_map()
    if 0 <= move_idx < len(move_map):
        return move_map[move_idx]
    return f"unknown({move_idx})"


def planes_to_board_representation(planes: np.ndarray) -> tuple[str, str, dict]:
    """
    Convert input planes back to board representation for both boards.
    
    Planes format (64 channels):
    Board A (channels 0-31):
      0-5: Our pieces (P,N,B,R,Q,K) [from team perspective]
      6-11: Opponent pieces (P,N,B,R,Q,K) [from team perspective]
      12-16: Our pocket pieces (P,N,R,B,Q)
      17-21: Opponent pocket pieces (P,N,R,B,Q)
      22: Promoted pieces
      23: En passant square
      24: Color info (1=white from team perspective)
      25: Is our turn (1=on turn)
      26: Constant plane (1)
      27-30: Castling rights (KQkq)
      31: Time advantage (has sitting)
    
    Board B (channels 32-63): same structure
    
    Returns: (board_a_repr, board_b_repr, metadata)
    """
    
    def get_board_representation(board_planes: np.ndarray, board_idx: int) -> tuple[str, dict]:
        """Convert 32 channels for one board to board representation."""
        
        # Determine perspective
        color_info = board_planes[24, 0, 0]  # 1 if white from team perspective
        on_turn = board_planes[25, 0, 0]  # 1 if this board is on turn
        
        # Extract piece positions
        # Note: planes are ALREADY from player's perspective (flipped for black)
        # When displaying, we show from player's perspective (their pieces at bottom)
        piece_chars = ['P', 'N', 'B', 'R', 'Q', 'K']
        board_str = []
        
        # Build board representation from rank 7 (top) to rank 0 (bottom) as displayed
        # The planes are already oriented with current player at bottom
        for rank in range(7, -1, -1):
            rank_str = []
            for file in range(8):
                square = rank * 8 + file
                piece = '.'
                
                # Check our pieces (0-5)
                for piece_idx in range(6):
                    if board_planes[piece_idx, rank, file] > 0.5:
                        piece = piece_chars[piece_idx]
                        break
                
                # Check opponent pieces (6-11)
                if piece == '.':
                    for piece_idx in range(6):
                        if board_planes[6 + piece_idx, rank, file] > 0.5:
                            piece = piece_chars[piece_idx].lower()
                            break
                
                rank_str.append(piece)
            board_str.append(' '.join(rank_str))
        
        board_repr = '\n'.join(board_str)
        
        # Castling rights (channels 27-30)
        castling_chars = ['K', 'Q', 'k', 'q']
        castling = ''.join([char for i, char in enumerate(castling_chars) 
                           if board_planes[27 + i, 0, 0] > 0.5])
        if not castling:
            castling = '-'
        
        # En passant (channel 23)
        ep_square = '-'
        for row in range(8):
            for col in range(8):
                if board_planes[23, row, col] > 0.5:
                    ep_square = chess.SQUARE_NAMES[row * 8 + col]
                    break
            if ep_square != '-':
                break
        
        # Pocket pieces (stored as actual counts 0-16 in uint8)
        pocket_chars = ['P', 'N', 'B', 'R', 'Q']  # Order: Pawn, Knight, Bishop, Rook, Queen
        our_pocket = []
        opp_pocket = []
        
        for i, char in enumerate(pocket_chars):
            # Read actual count directly (0-16)
            our_count = int(board_planes[12 + i, 0, 0] + 0.5)
            opp_count = int(board_planes[17 + i, 0, 0] + 0.5)
            if our_count > 0:
                our_pocket.append(f"{char}x{our_count}")
            if opp_count > 0:
                opp_pocket.append(f"{char.lower()}x{opp_count}")
        
        metadata = {
            'on_turn': bool(on_turn > 0.5),
            'castling': castling,
            'ep_square': ep_square,
            'our_pocket': ', '.join(our_pocket) if our_pocket else 'empty',
            'opp_pocket': ', '.join(opp_pocket) if opp_pocket else 'empty',
            'color_info': color_info
        }
        
        return board_repr, metadata
    
    # Split planes into two boards
    board_a_planes = planes[:32]
    board_b_planes = planes[32:]
    
    board_a_repr, metadata_a = get_board_representation(board_a_planes, 0)
    board_b_repr, metadata_b = get_board_representation(board_b_planes, 1)
    
    metadata = {'board_a': metadata_a, 'board_b': metadata_b}
    
    return board_a_repr, board_b_repr, metadata


def is_early_game(planes: np.ndarray) -> bool:
    """
    Check if a position is from early in the game.
    
    Heuristics:
    - Few pieces in pockets (< 3 total pieces)
    - Most pieces still on board (> 24 pieces total across both boards)
    """
    # Check both boards
    total_pocket_pieces = 0
    total_board_pieces = 0
    
    for board_offset in [0, 32]:
        # Count pocket pieces (channels 12-16 and 17-21)
        for i in range(5):  # 5 piece types in pocket
            total_pocket_pieces += int(planes[board_offset + 12 + i, 0, 0] + 0.5)
            total_pocket_pieces += int(planes[board_offset + 17 + i, 0, 0] + 0.5)
        
        # Count pieces on board (channels 0-11)
        for piece_ch in range(12):  # Our pieces (0-5) + Opponent pieces (6-11)
            total_board_pieces += np.sum(planes[board_offset + piece_ch] > 0.5)
    
    # Early game: few captured pieces, many pieces on board
    return total_pocket_pieces < 3 and total_board_pieces > 24


def analyze_sample(sample_idx: int, row: dict, show_planes: bool = False):
    """Analyze and print information about a single training sample."""
    
    # Read planes
    x_bytes = row['x']
    planes = np.frombuffer(x_bytes, dtype=np.uint8).reshape(NB_INPUT_CHANNELS, 8, 8).astype(float)
    
    # Read policies
    policy_a_bytes = row['policy_a']
    policy_a = np.frombuffer(policy_a_bytes, dtype=np.float32)
    
    policy_b_bytes = row['policy_b']
    policy_b = np.frombuffer(policy_b_bytes, dtype=np.float32)
    
    # Read outcome
    outcome = row['y_value']
    
    # Convert planes to board representation
    board_a_repr, board_b_repr, metadata = planes_to_board_representation(planes)
    
    # Print results
    print(f"\n{'='*80}")
    print(f"Sample #{sample_idx}")
    print(f"{'='*80}")
    
    # Print boards side by side
    board_a_lines = board_a_repr.split('\n')
    board_b_lines = board_b_repr.split('\n')
    
    # Each board line is 15 chars (8 pieces + 7 spaces)
    board_width = 15
    
    print(f"\n{'Board A':^{board_width}s}   {'Board B':^{board_width}s}")
    print(f"{'-'*board_width}   {'-'*board_width}")
    for line_a, line_b in zip(board_a_lines, board_b_lines):
        print(f"{line_a:<{board_width}s}   {line_b}")
    
    # Print metadata side by side
    print(f"\n{'Board A Info':^24s}   {'Board B Info':^24s}")
    print(f"  On turn: {str(metadata['board_a']['on_turn']):14s}   On turn: {metadata['board_b']['on_turn']}")
    print(f"  Castling: {metadata['board_a']['castling']:13s}   Castling: {metadata['board_b']['castling']}")
    print(f"  EP square: {metadata['board_a']['ep_square']:12s}   EP square: {metadata['board_b']['ep_square']}")
    print(f"  Our pocket: {metadata['board_a']['our_pocket']:11s}   Our pocket: {metadata['board_b']['our_pocket']}")
    print(f"  Opp pocket: {metadata['board_a']['opp_pocket']:11s}   Opp pocket: {metadata['board_b']['opp_pocket']}")
    
    print(f"\n(uppercase=our pieces, lowercase=opponent)")
    print(f"\nOutcome: {outcome:.3f} (1.0=team 0 wins, -1.0=team 1 wins, 0.0=draw)")
    
    # Print policy sums for verification
    policy_a_sum = np.sum(policy_a)
    policy_b_sum = np.sum(policy_b)
    print(f"\nPolicy sums: Board A = {policy_a_sum:.6f}, Board B = {policy_b_sum:.6f}")
    
    # Print move distribution for Board A
    print(f"\nBoard A Policy Distribution:")
    top_moves_a = np.argsort(policy_a)[-10:][::-1]  # Top 10 moves
    shown_a = 0
    for move_idx in top_moves_a:
        prob = policy_a[move_idx]
        if prob > 0.001 or shown_a == 0:  # Always show at least the top move
            move_str = decode_move_index(move_idx)
            print(f"  {move_str:12s} (idx {move_idx:4d}): {prob:.4f} ({prob*100:.2f}%)")
            shown_a += 1
            if prob <= 0.001 and shown_a >= 1:  # Stop after first move if under threshold
                break
    
    # Print move distribution for Board B
    print(f"\nBoard B Policy Distribution:")
    top_moves_b = np.argsort(policy_b)[-10:][::-1]  # Top 10 moves
    shown_b = 0
    for move_idx in top_moves_b:
        prob = policy_b[move_idx]
        if prob > 0.001 or shown_b == 0:  # Always show at least the top move
            move_str = decode_move_index(move_idx)
            print(f"  {move_str:12s} (idx {move_idx:4d}): {prob:.4f} ({prob*100:.2f}%)")
            shown_b += 1
            if prob <= 0.001 and shown_b >= 1:  # Stop after first move if under threshold
                break
    
    # Optional: show plane values
    if show_planes:
        print(f"\nPlane values (first 5 channels of Board A):")
        for ch in range(min(5, NB_INPUT_CHANNELS)):
            print(f"\nChannel {ch}:")
            print(planes[ch])


def main():
    parser = argparse.ArgumentParser(
        description='Analyze training data from selfplay parquet files'
    )
    parser.add_argument(
        '--data-dir',
        type=str,
        default='/home/ben/hivemind/engine/selfplay_games/training_data_parquet',
        help='Directory containing parquet files'
    )
    parser.add_argument(
        '--num-samples',
        type=int,
        default=5,
        help='Number of samples to analyze per file'
    )
    parser.add_argument(
        '--num-files',
        type=int,
        default=1,
        help='Number of parquet files to process'
    )
    parser.add_argument(
        '--show-planes',
        action='store_true',
        help='Show raw plane values'
    )
    parser.add_argument(
        '--sample-indices',
        type=str,
        help='Comma-separated list of specific sample indices to analyze (e.g., "0,5,10")'
    )
    parser.add_argument(
        '--early-game',
        action='store_true',
        help='Filter to show only early-game positions (few captured pieces)'
    )
    
    args = parser.parse_args()
    
    # Find parquet files
    parquet_files = sorted(glob.glob(os.path.join(args.data_dir, '*.parquet')))
    
    if not parquet_files:
        print(f"No parquet files found in {args.data_dir}")
        return
    
    print(f"Found {len(parquet_files)} parquet files in {args.data_dir}")
    
    # Process files
    for file_idx, file_path in enumerate(parquet_files[:args.num_files]):
        print(f"\n{'#'*80}")
        print(f"Processing file: {os.path.basename(file_path)}")
        print(f"{'#'*80}")
        
        # Read parquet file
        df = pl.read_parquet(file_path)
        total_samples = len(df)
        
        print(f"Total samples in file: {total_samples}")
        
        # Determine which samples to analyze
        if args.sample_indices:
            sample_indices = [int(x) for x in args.sample_indices.split(',')]
        elif args.early_game:
            # Search for early-game positions
            print("Searching for early-game positions...")
            sample_indices = []
            for i in range(total_samples):
                row = df.row(i, named=True)
                x_bytes = row['x']
                planes = np.frombuffer(x_bytes, dtype=np.uint8).reshape(NB_INPUT_CHANNELS, 8, 8).astype(float)
                if is_early_game(planes):
                    sample_indices.append(i)
                    if len(sample_indices) >= args.num_samples:
                        break
            print(f"Found {len(sample_indices)} early-game positions")
        else:
            # Analyze evenly spaced samples
            if total_samples <= args.num_samples:
                sample_indices = list(range(total_samples))
            else:
                step = total_samples // args.num_samples
                sample_indices = [i * step for i in range(args.num_samples)]
        
        # Analyze samples
        for sample_idx in sample_indices:
            row = df.row(sample_idx, named=True)
            analyze_sample(sample_idx, row, args.show_planes)


if __name__ == '__main__':
    main()
